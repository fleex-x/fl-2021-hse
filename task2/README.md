## Задание 2

Так как моим любимым языком по праву можно назвать `C++`, то я решил написать задание на этом языке.
При этом, вся мощь этого языка заключается в шаблонах, а вся мощь шаблонов заключатеся в вычислениях на стадии компиляции. Поэтому я решил написать compile-time-regex-mathcing!. На самом деле я решил это сделать после того, как увидел pattern matching в хаскеле, который очень похож на специализации шаблонов. Но так 
как в шаблонах специализации сильно слабее, то там пришлось понакручивать if-ов, и теперь это не то чтобы выглядит совсем красиво. 

Здесь лежит 2 версии, одна с оптимизациями, другая без. На первом скрине можно 
увидеть, что компиляция части тестов без оптимизации занимала 30 секунд. При этом компиляция всех
тестов решения с оптимизациями занимает всего 0.5 секунд. По понятным причинам стало лучше, так как
во многих ситуациях вместо того, чтобы дальше разрастать дерево, алгоритм теперь просто останавливается, или
идет в меньшее количество веток рекурсии. Также во второй версии есть `nullable_bool_v`, который сразу считает значение в типе `bool`.

У вычислений на шаблонах есть 1 особенность: по факту все эти вычисления происходят с автоматической мемоизацией, поэтому в некотором смысле это достаточно быстро (если конечно не учитывать то, что на стадии компиляции все происходит невероятно медленно).

У вычислений на шаблонах есть 1 особенность: по факту все эти вычисления происходят с автоматической мемоизацией, поэтому в некотором смысле это достаточно быстро (если конечно не учитывать то, что на стадии компиляции все происходит невероятно медленно). По итогу у меня получилось найти тест, на котором быстрое решение компилируется хотя бы секунду, это последний тест в тестах для быстрого решения.

Чтобы запустить решения достаточно зайти в директорию решения и ввести `cmake . && make`.

